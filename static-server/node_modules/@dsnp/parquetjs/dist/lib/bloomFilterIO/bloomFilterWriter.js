"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSerializedBloomFilterData = exports.setFilterOffset = exports.serializeFilterData = exports.serializeFilterHeaders = exports.createSBBF = void 0;
const util_1 = __importDefault(require("../util"));
const parquet_types_1 = __importDefault(require("../../gen-nodejs/parquet_types"));
const sbbf_1 = __importDefault(require("../bloom/sbbf"));
const createSBBF = (params) => {
    const { numFilterBytes, falsePositiveRate, numDistinct } = params;
    const bloomFilter = new sbbf_1.default();
    const hasOptions = numFilterBytes || falsePositiveRate || numDistinct;
    if (!hasOptions)
        return bloomFilter.init();
    if (numFilterBytes)
        return bloomFilter.setOptionNumFilterBytes(numFilterBytes).init();
    if (falsePositiveRate)
        bloomFilter.setOptionFalsePositiveRate(falsePositiveRate);
    if (numDistinct)
        bloomFilter.setOptionNumDistinct(numDistinct);
    return bloomFilter.init();
};
exports.createSBBF = createSBBF;
const serializeFilterBlocks = (blocks) => Buffer.concat(blocks.map((block) => Buffer.from(block.buffer)));
const buildFilterHeader = (numBytes) => {
    const bloomFilterHeader = new parquet_types_1.default.BloomFilterHeader();
    bloomFilterHeader.numBytes = numBytes;
    bloomFilterHeader.algorithm = new parquet_types_1.default.BloomFilterAlgorithm();
    bloomFilterHeader.hash = new parquet_types_1.default.BloomFilterHash();
    bloomFilterHeader.compression = new parquet_types_1.default.BloomFilterCompression();
    return bloomFilterHeader;
};
const serializeFilterHeaders = (numberOfBytes) => {
    const bloomFilterHeader = buildFilterHeader(numberOfBytes);
    return util_1.default.serializeThrift(bloomFilterHeader);
};
exports.serializeFilterHeaders = serializeFilterHeaders;
const serializeFilterData = (params) => {
    const serializedFilterBlocks = serializeFilterBlocks(params.filterBlocks);
    const serializedFilterHeaders = exports.serializeFilterHeaders(params.filterByteSize);
    return Buffer.concat([serializedFilterHeaders, serializedFilterBlocks]);
};
exports.serializeFilterData = serializeFilterData;
const setFilterOffset = (column, offset) => {
    column.meta_data.bloom_filter_offset = offset;
};
exports.setFilterOffset = setFilterOffset;
const getSerializedBloomFilterData = (splitBlockBloomFilter) => {
    const filterBlocks = splitBlockBloomFilter.getFilter();
    const filterByteSize = splitBlockBloomFilter.getNumFilterBytes();
    return exports.serializeFilterData({ filterBlocks, filterByteSize });
};
exports.getSerializedBloomFilterData = getSerializedBloomFilterData;
//# sourceMappingURL=bloomFilterWriter.js.map