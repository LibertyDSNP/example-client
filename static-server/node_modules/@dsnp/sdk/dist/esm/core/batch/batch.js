var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { ParquetReader, ParquetWriter, ParquetSchema } from "@dsnp/parquetjs";
import { keccak256 } from "js-sha3";
import { requireGetStore } from "../../config";
import { getSchemaFor, getBloomFilterOptionsFor } from "./parquetSchema";
import { MixedTypeBatchError, EmptyBatchError } from "../utilities";
export const createFile = (targetPath, messages, opts) => { var messages_1, messages_1_1; return __awaiter(void 0, void 0, void 0, function* () {
    var e_1, _a;
    let dsnpType;
    try {
        for (messages_1 = __asyncValues(messages); messages_1_1 = yield messages_1.next(), !messages_1_1.done;) {
            const message = messages_1_1.value;
            dsnpType = message.dsnpType;
            break;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (messages_1_1 && !messages_1_1.done && (_a = messages_1.return)) yield _a.call(messages_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (dsnpType === undefined)
        throw new EmptyBatchError();
    const schema = new ParquetSchema(getSchemaFor(dsnpType));
    const bloomFilterOptions = getBloomFilterOptionsFor(dsnpType);
    const store = requireGetStore(opts);
    const hashGenerator = keccak256.create();
    const url = yield store.putStream(targetPath, (writeStream) => __awaiter(void 0, void 0, void 0, function* () {
        const hashingWriteStream = Object.assign(Object.assign({}, writeStream), { write: (chunk, ...args) => {
                hashGenerator.update(chunk);
                return writeStream.write(chunk, ...args);
            } });
        yield writeBatch(hashingWriteStream, schema, messages, bloomFilterOptions);
    }));
    return {
        url,
        hash: hashGenerator.hex(),
    };
}); };
export const writeBatch = (writeStream, schema, messages, opts) => { var messages_2, messages_2_1; return __awaiter(void 0, void 0, void 0, function* () {
    var e_2, _a;
    const writer = yield ParquetWriter.openStream(schema, writeStream, opts);
    let firstDsnpType;
    try {
        for (messages_2 = __asyncValues(messages); messages_2_1 = yield messages_2.next(), !messages_2_1.done;) {
            const message = messages_2_1.value;
            if (firstDsnpType === undefined)
                firstDsnpType = message.dsnpType;
            if (message.dsnpType != firstDsnpType)
                throw new MixedTypeBatchError(writeStream);
            writer.appendRow(message);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (messages_2_1 && !messages_2_1.done && (_a = messages_2.return)) yield _a.call(messages_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (firstDsnpType === undefined)
        throw new EmptyBatchError(writeStream);
    yield writer.close();
}); };
export const openURL = (url) => __awaiter(void 0, void 0, void 0, function* () { return ParquetReader.openUrl(url); });
export const openFile = (path) => __awaiter(void 0, void 0, void 0, function* () { return ParquetReader.openFile(path); });
export const readFile = (reader, doReadRow) => __awaiter(void 0, void 0, void 0, function* () {
    const cursor = reader.getCursor();
    let record = null;
    while ((record = yield cursor.next())) {
        doReadRow(record);
    }
    return reader.close();
});
export const includes = (reader, column, item) => __awaiter(void 0, void 0, void 0, function* () {
    const bloomFilterData = yield reader.getBloomFilters([column]);
    return (bloomFilterData[column] || []).some((data) => data.sbbf.check(item));
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmF0Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29yZS9iYXRjaC9iYXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBTyxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDOUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUdwQyxPQUFPLEVBQWMsZUFBZSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRTNELE9BQU8sRUFBRSxZQUFZLEVBQUUsd0JBQXdCLEVBQThCLE1BQU0saUJBQWlCLENBQUM7QUFHckcsT0FBTyxFQUF1QixtQkFBbUIsRUFBRSxlQUFlLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFnQ3pGLE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixVQUFrQixFQUNsQixRQUEwQixFQUMxQixJQUFpQixFQUNPLEVBQUU7O0lBQzFCLElBQUksUUFBUSxDQUFDOztRQUViLEtBQTRCLGFBQUEsY0FBQSxRQUFRLENBQUE7WUFBekIsTUFBTSxPQUFPLHFCQUFBLENBQUE7WUFDdEIsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDNUIsTUFBTTtTQUNQOzs7Ozs7Ozs7SUFFRCxJQUFJLFFBQVEsS0FBSyxTQUFTO1FBQUUsTUFBTSxJQUFJLGVBQWUsRUFBRSxDQUFDO0lBRXhELE1BQU0sTUFBTSxHQUFHLElBQUksYUFBYSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pELE1BQU0sa0JBQWtCLEdBQUcsd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFOUQsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN6QyxNQUFNLEdBQUcsR0FBRyxNQUFNLEtB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