"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const parquetjs_1 = require("@dsnp/parquetjs");
const batch = __importStar(require("./batch"));
const dsnpGenerators_1 = require("../../generators/dsnpGenerators");
const parquetSchema_1 = require("./parquetSchema");
const testStore_1 = __importDefault(require("../../test/testStore"));
const utilities_1 = require("../utilities");
describe("batch", () => {
    describe("includes", () => {
        let reader;
        beforeEach(() => {
            const MockSplitBlockBloomFilter = {
                check: jest.fn(),
            };
            const bloomFilterData = {
                name: [
                    {
                        sbbf: MockSplitBlockBloomFilter,
                        columnName: "name",
                        rowGroupIndex: 0,
                    },
                ],
            };
            reader = { getBloomFilters: jest.fn().mockResolvedValue(bloomFilterData) };
        });
        it("calls getBloomFilter", () => {
            batch.includes(reader, "name", "banana");
            expect(reader.getBloomFilters.mock.calls.length).toBe(1);
        });
    });
    describe("#writeBatch", () => {
        const parquetWriterInstance = {
            appendRow: jest.fn().mockImplementation((message) => __awaiter(void 0, void 0, void 0, function* () { return message; })),
            close: jest.fn(),
        };
        const writeStream = { write: jest.fn(), end: jest.fn() };
        const { writeBatch } = batch;
        beforeAll(() => {
            jest.spyOn(parquetjs_1.ParquetWriter, "openStream").mockResolvedValue(parquetWriterInstance);
        });
        beforeEach(jest.clearAllMocks);
        afterAll(jest.restoreAllMocks);
        describe("when passed a valid message iterator", () => {
            const messages = [Object.assign(Object.assign({}, dsnpGenerators_1.generateBroadcast()), { signature: "0xfa1ce" })];
            it("calls ParquetWriter#openStream to start a writable stream", () => __awaiter(void 0, void 0, void 0, function* () {
                yield writeBatch(writeStream, parquetSchema_1.BroadcastSchema, messages);
                expect(parquetjs_1.ParquetWriter.openStream).toHaveBeenCalled();
            }));
            it("calls ParquetWriter#appendRow to add a row to parquet stream", () => __awaiter(void 0, void 0, void 0, function* () {
                yield writeBatch(writeStream, parquetSchema_1.BroadcastSchema, messages);
                expect(parquetWriterInstance.appendRow).toHaveBeenCalledTimes(1);
            }));
            it("calls ParquetWriter#close to end the stream", () => __awaiter(void 0, void 0, void 0, function* () {
                yield writeBatch(writeStream, parquetSchema_1.BroadcastSchema, messages);
                expect(parquetWriterInstance.close).toHaveBeenCalledTimes(1);
            }));
        });
        describe("when passed a message iterator containing multiple DSNP types", () => {
            const badMessages = [
                Object.assign(Object.assign({}, dsnpGenerators_1.generateBroadcast()), { signature: "0xfa1ce" }),
                Object.assign(Object.assign({}, dsnpGenerators_1.generateReply()), { signature: "0xfa1ce" }),
            ];
            it("throws MixedDSNPTypeError", () => __awaiter(void 0, void 0, void 0, function* () {
                yield expect(writeBatch(writeStream, parquetSchema_1.BroadcastSchema, badMessages)).rejects.toBeInstanceOf(utilities_1.MixedTypeBatchError);
            }));
            it("includes the write stream handle in the thrown error", () => __awaiter(void 0, void 0, void 0, function* () {
                yield expect(writeBatch(writeStream, parquetSchema_1.BroadcastSchema, badMessages)).rejects.toMatchObject({
                    fileHandle: writeStream,
                });
            }));
        });
        describe("when passed a message iterator containing no messages", () => {
            const badMessages = [];
            it("throws MixedDSNPTypeError", () => __awaiter(void 0, void 0, void 0, function* () {
                yield expect(writeBatch(writeStream, parquetSchema_1.BroadcastSchema, badMessages)).rejects.toBeInstanceOf(utilities_1.EmptyBatchError);
            }));
            it("includes the write stream handle in the thrown error", () => __awaiter(void 0, void 0, void 0, function* () {
                yield expect(writeBatch(writeStream, parquetSchema_1.BroadcastSchema, badMessages)).rejects.toMatchObject({
                    fileHandle: writeStream,
                });
            }));
        });
    });
    describe("#createFile", () => {
        const { createFile } = batch;
        const messages = [Object.assign(Object.assign({}, dsnpGenerators_1.generateBroadcast()), { signature: "0xfa1ce" })];
        describe("when passed a valid message iterator", () => {
            it("calls putStream to start streaming", () => __awaiter(void 0, void 0, void 0, function* () {
                const mockStore = new testStore_1.default();
                jest.spyOn(mockStore, "putStream");
                yield createFile("batch.parquet", messages, { store: mockStore });
                expect(mockStore.putStream).toHaveBeenCalled();
            }));
            it("calls #writeBatch to stream write parquet", () => __awaiter(void 0, void 0, void 0, function* () {
                jest.spyOn(batch, "writeBatch");
                const mockStore = new testStore_1.default();
                yield createFile("batch.parquet", messages, { store: mockStore });
                const file = mockStore.getStore()["batch.parquet"];
                const reader = yield parquetjs_1.ParquetReader.openBuffer(file);
                expect(batch.writeBatch).toHaveBeenCalled();
                expect(reader.metadata.num_rows.buffer.toString("hex")).toEqual("0000000000000001");
            }));
        });
        describe("when passed a message iterator containing no messages", () => {
            const badMessages = [];
            it("throws MixedDSNPTypeError", () => __awaiter(void 0, void 0, void 0, function* () {
                const mockStore = new testStore_1.default();
                yield expect(createFile("batch.parquet", badMessages, { store: mockStore })).rejects.toBeInstanceOf(utilities_1.EmptyBatchError);
            }));
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmF0Y2gudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL2JhdGNoL2JhdGNoLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQStEO0FBRS9ELCtDQUFpQztBQUVqQyxvRUFBbUY7QUFDbkYsbURBQWtEO0FBQ2xELHFFQUE2QztBQUM3Qyw0Q0FBb0U7QUFFcEUsUUFBUSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7SUFDckIsUUFBUSxDQUFDLFVBQVUsRUFBRSxHQUFHLEVBQUU7UUFDeEIsSUFBSSxNQUE0QixDQUFDO1FBRWpDLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDZCxNQUFNLHlCQUF5QixHQUFHO2dCQUNoQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTthQUNqQixDQUFDO1lBRUYsTUFBTSxlQUFlLEdBQUc7Z0JBQ3RCLElBQUksRUFBRTtvQkFDSjt3QkFDRSxJQUFJLEVBQUUseUJBQXlCO3dCQUMvQixVQUFVLEVBQUUsTUFBTTt3QkFDbEIsYUFBYSxFQUFFLENBQUM7cUJBQ2pCO2lCQUNGO2FBQ0YsQ0FBQztZQUVGLE1BQU0sR0FBRyxFQUFFLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztRQUM3RSxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxHQUFHLEVBQUU7WUFDOUIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRXpDLE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFD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