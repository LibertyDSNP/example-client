"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMessageSignatureAuthorizedTo = exports.getDSNPRegistryUpdateEvents = exports.changeHandle = exports.changeAddress = exports.register = exports.resolveRegistration = void 0;
const ethers_1 = require("ethers");
const contract_1 = require("./contract");
const config_1 = require("../../config");
const typechain_1 = require("../../types/typechain");
const handles_1 = require("../../handles");
const identity_1 = require("./identity");
const messages_1 = require("../messages");
const identifiers_1 = require("../utilities/identifiers");
const CONTRACT_NAME = "Registry";
const resolveRegistration = (handle, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const contract = yield getContract(opts);
    try {
        const [dsnpUserId, contractAddr] = yield contract.resolveRegistration(handle);
        return {
            handle,
            dsnpUserId: identifiers_1.convertBigNumberToDSNPUserId(dsnpUserId),
            contractAddr,
        };
    }
    catch (e) {
        const error = e;
        const vmError = contract_1.getVmError(error);
        if (vmError === null || vmError === void 0 ? void 0 : vmError.includes("Handle does not exist")) {
            return null;
        }
        throw e;
    }
});
exports.resolveRegistration = resolveRegistration;
const register = (identityContractAddress, handle, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const contract = yield getContract(opts);
    const signer = config_1.requireGetSigner(opts);
    return yield contract.connect(signer).register(identityContractAddress, handle);
});
exports.register = register;
const changeAddress = (handle, identityContractAddress, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const contract = yield getContract(opts);
    const signer = config_1.requireGetSigner(opts);
    return yield contract.connect(signer).changeAddress(identityContractAddress, handle);
});
exports.changeAddress = changeAddress;
const changeHandle = (oldHandle, newHandle, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const contract = yield getContract(opts);
    const signer = config_1.requireGetSigner(opts);
    return yield contract.connect(signer).changeHandle(oldHandle, newHandle);
});
exports.changeHandle = changeHandle;
const getDSNPRegistryUpdateEvents = (filter, opts) => __awaiter(void 0, void 0, void 0, function* () {
    const dsnpUserId = filter.dsnpUserId ? identifiers_1.convertDSNPUserIdToBigNumber(filter.dsnpUserId) : undefined;
    const contract = yield getContract(opts);
    const logs = yield contract.queryFilter(contract.filters.DSNPRegistryUpdate(dsnpUserId, filter.contractAddr));
    return logs.map((desc) => {
        const [id, addr, handle] = desc.args;
        const dsnpUserId = identifiers_1.convertBigNumberToDSNPUserId(id);
        return { contractAddr: addr, dsnpUserId, handle };
    });
});
exports.getDSNPRegistryUpdateEvents = getDSNPRegistryUpdateEvents;
const isMessageSignatureAuthorizedTo = (signature, message, dsnpUserId, permission, blockTag, opts) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const reg = yield handles_1.resolveId(dsnpUserId);
    if (!reg)
        throw config_1.MissingContract;
    const provider = config_1.requireGetProvider(opts);
    let blockNumber = 0x0;
    if (blockTag) {
        const bn = (_a = (yield (provider === null || provider === void 0 ? void 0 : provider.getBlock(blockNumber)))) === null || _a === void 0 ? void 0 : _a.number;
        if (bn)
            blockNumber = bn;
    }
    const messageString = typeof message === "string" ? message : messages_1.serialize(message);
    const signerAddr = ethers_1.ethers.utils.verifyMessage(messageString, signature);
    return identity_1.isAuthorizedTo(signerAddr, reg.contractAddr, permission, blockNumber);
});
exports.isMessageSignatureAuthorizedTo = isMessageSignatureAuthorizedTo;
const getContract = (opts) => __awaiter(void 0, void 0, void 0, function* () {
    const { registry } = config_1.getContracts(opts);
    const provider = config_1.requireGetProvider(opts);
    const address = registry || (yield contract_1.getContractAddress(provider, CONTRACT_NAME));
    if (!address)
        throw config_1.MissingContract;
    return typechain_1.Registry__factory.connect(address, provider);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaXN0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29yZS9jb250cmFjdHMvcmVnaXN0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsbUNBQWdDO0FBQ2hDLHlDQUFxRTtBQUVyRSx5Q0FBK0c7QUFFL0cscURBQTBEO0FBRTFELDJDQUEwQztBQUMxQyx5Q0FBNEM7QUFDNUMsMENBQXFEO0FBQ3JELDBEQUFrSDtBQUVsSCxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUM7QUFpQjFCLE1BQU0sbUJBQW1CLEdBQUcsQ0FBTyxNQUFjLEVBQUUsSUFBaUIsRUFBZ0MsRUFBRTtJQUMzRyxNQUFNLFFBQVEsR0FBRyxNQUFNLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxJQUFJO1FBQ0YsTUFBTSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsR0FBRyxNQUFNLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5RSxPQUFPO1lBQ0wsTUFBTTtZQUNOLFVBQVUsRUFBRSwwQ0FBNEIsQ0FBQyxVQUFVLENBQUM7WUFDcEQsWUFBWTtTQUNiLENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsTUFBTSxLQUFLLEdBQVksQ0FBQyxDQUFDO1FBQ3pCLE1BQU0sT0FBTyxHQUFHLHFCQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsSUFBSSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsUUFBUSxDQUFDLHVCQUF1QixDQUFDLEVBQUU7WUFDOUMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE1BQU0sQ0FBQyxDQUFDO0tBQ1Q7QUFDSCxDQUFDLENBQUEsQ0FBQztBQWpCVyxRQUFBLG1CQUFtQix1QkFpQjlCO0FBVUssTUFBTSxRQUFRLEdBQUcsQ0FDdEIsdUJBQWtDLEVBQ2xDLE1BQWMsRUFDZCxJQUFpQixFQUNhLEVBQUU7SUFDaEMsTUFBTSxR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